#this cell is for notes and models with scaling and no scaling...


# with scaling start:

# def test_parameters(layers, train_input_features, test_input_features):
#     train_inputs = [list(pair) for pair in train_input_features]
#     test_inputs = [list(pair) for pair in test_input_features]

#     return average_results(20, layers, train_inputs, test_inputs)
    

# def average_results(nof_runs, layers, train_inputs, text_inputs):
#     no_rounding = 0
#     rounding = 0
#     for _ in range(nof_runs):
#         #issue here
#         pair = analysis(layers, train_inputs, text_inputs)
#         no_rounding+=pair[0]
#         rounding+=pair[1]
#     return float(no_rounding/nof_runs), float(rounding/nof_runs)


# def analysis(layers, train_inputs, test_inputs):
#     #scale input features
#     #scalar 1:
#     input_scalar = StandardScaler()
#     train_inputs_scaled = input_scalar.fit_transform(train_inputs)

#     #scale target values
#     #scalar 2:
#     target_scalar = StandardScaler()
#     true_rating_train_scaled = target_scalar.fit_transform(np.array(train_users.user_to_target_rating).reshape(-1, 1))
#     true_rating_train_scaled = np.reshape(true_rating_train_scaled, len(true_rating_train_scaled))

#     #build and train model
#     reg = MLPRegressor(hidden_layer_sizes = layers, solver = "adam",  max_iter = 1000)
#     reg.fit(train_inputs_scaled, true_rating_train_scaled)

#     #show importance of different inputs features...
#     results = permutation_importance(reg, train_inputs_scaled,true_rating_train_scaled)
#     print(results["importances_mean"])

#     #scale inputs features
#     #scalar 3: 
#     input_scalar = StandardScaler()
#     test_inputs_scaled = input_scalar.fit_transform(test_inputs)

#     #predict the scaled verison of ouptuts
#     scaled_predictions = reg.predict(test_inputs_scaled)

#     #change back into regular outputs to be tested with target scalar above...
#     #not sure if this is correct???
#     #would it be better to use a new scalar object???
#     #need to know the mean and the std dev of the orginal predictions
#     #scalar 4:
#     predictions = target_scalar.inverse_transform(np.array(scaled_predictions).reshape(-1, 1))

#     #test with and without roundings...
#     rounded_predictions = []
#     for item in predictions:
#         rounded_predictions.append(float(round(item[0]*2)/2.0))

#     #evaluation metric 1
#     return(r2_score(test_users.user_to_target_rating, predictions), 
#         r2_score(test_users.user_to_target_rating, rounded_predictions))

#     #evaluation metric 2
#     # return(mean_squared_error(test_users.user_to_target_rating, predictions), 
#     #         mean_squared_error(test_users.user_to_target_rating, rounded_predictions))


# print(test_parameters((10,10,10), 
#       zip(train_users.feature_1, train_users.feature_3),
#       zip(test_users.feature_1, test_users.feature_3)))


# print(test_users.feature_1)
# print(test_users.feature_3)
# print(test_users.user_to_target_rating)

# ...with scaling done


#without scaling:

# def test_parameters(layers, train_input_features, test_input_features):
#     train_inputs = [list(pair) for pair in train_input_features]
#     test_inputs = [list(pair) for pair in test_input_features]

#     return average_results(20, layers, train_inputs, test_inputs)
    


# def average_results(nof_runs, layers, train_inputs, text_inputs):
#     no_rounding = 0
#     rounding = 0
#     for _ in range(nof_runs):
#         #issue here
#         pair = analysis(layers, train_inputs, text_inputs)
#         no_rounding+=pair[0]
#         rounding+=pair[1]
#     return float(no_rounding/nof_runs), float(rounding/nof_runs)


# def analysis(layers, train_inputs, test_inputs):
#     #build and train model
#     reg = MLPRegressor(hidden_layer_sizes = layers, solver = "adam",  max_iter = 1000)
#     reg.fit(train_inputs, train_users.user_to_target_rating)

#     #show importance of different inputs features...
#     results = permutation_importance(reg, train_inputs, train_users.user_to_target_rating)
#     print(results["importances_mean"])


#     predictions = reg.predict(test_inputs)

#     #testing if needed...
#     # predictions = np.array(predictions).reshape(-1, 1)

#     #test with and without roundings...
#     rounded_predictions = []
#     for item in predictions:
#         # rounded_predictions.append(float(round(item[0]*2)/2.0))
#         rounded_predictions.append(float(round(item*2)/2.0))

#     #evaluation metric 1:
#     return(r2_score(test_users.user_to_target_rating, predictions), 
#         r2_score(test_users.user_to_target_rating, rounded_predictions))

#     #evaluation metric 2:
#     # return(mean_squared_error(test_users.user_to_target_rating, predictions), 
#     #         mean_squared_error(test_users.user_to_target_rating, rounded_predictions))


# print(test_parameters((10,10,10), 
#       zip(train_users.feature_1, train_users.feature_3),
#       zip(test_users.feature_1, test_users.feature_3)))

# print(test_users.feature_1)
# print(test_users.feature_3)
# print(test_users.user_to_target_rating)


# def predict(user, user_to_word_counts_transformed, user_to_target_word_counts_transformed,
#             user_to_target_word_counts, user_to_word_counts, user_to_ratings):


#     cosine_sim = cosine_similarity(X = user_to_word_counts_transformed[user] ,Y = [user_to_target_word_counts_transformed[user]])
    
#     cosine_sim = np.reshape(cosine_sim,  (len(cosine_sim)))

#     ratings = [user_to_ratings[user][x] for x in range(len(user_to_ratings[user])) if user_to_ratings[user][x] != -1]


#     #use the movie thats are most similair to the movie in question 

#     #option 1: 
#     # combined = zip(cosine_sim, ratings)
#     # combined = sorted(combined, key=lambda x: x[0], reverse=False)
#     # avg = 0
#     # nof = 10.0
#     # for i in range(int(nof)):
#     #     avg += combined[i][1]
#     # return float(avg/nof)

#     #option 2:
#     # avg = 0
#     # for i in range(len(ratings)):
#     #     avg += ratings[i]
#     # return float(avg/len(ratings))

#     #option 3: 
#     combined = zip(cosine_sim, ratings)
#     combined = sorted(combined, key=lambda x: x[0], reverse=True)
#     avg = 0
#     nof = 10.0
#     for i in range(int(nof)):
#         avg += combined[i][1]
#     return float(avg/nof)




# def populate_5(user_to_word_counts_transformed, user_to_target_word_counts_transformed,
#                user_to_movie_id_to_rating, feature_1,
#                 user_to_target_word_counts, user_to_word_counts,
#                 user_to_ratings):
#     for i in range(len(user_to_movie_id_to_rating)):
#         feature_1.append(predict(i, user_to_word_counts_transformed, user_to_target_word_counts_transformed,
#                                   user_to_target_word_counts, user_to_word_counts, user_to_ratings))



# populate_5(train_users.user_to_word_counts_transformed, train_users.user_to_target_word_counts_transformed,
#            train_users.user_to_movie_id_to_rating, train_users.feature_1,
#                 train_users.user_to_target_word_counts, train_users.user_to_word_counts,
#                 train_users.user_to_ratings)

# populate_5(test_users.user_to_word_counts_transformed, test_users.user_to_target_word_counts_transformed,
#            test_users.user_to_movie_id_to_rating, test_users.feature_1,
#                 test_users.user_to_target_word_counts, test_users.user_to_word_counts,
#                 test_users.user_to_ratings)

# del train_users.user_to_word_counts
# del test_users.user_to_word_counts
# del train_users.user_to_word_counts_transformed
# del test_users.user_to_word_counts_transformed
# del train_users.user_to_target_word_counts
# del test_users.user_to_target_word_counts
# del train_users.user_to_target_word_counts_transformed
# del test_users.user_to_target_word_counts_transformed
# del train_users.user_to_ratings
# del test_users.user_to_ratings


#note: for some reason feature 2 out performs feature 3 as a feature...

# for i in range(len(train_users.user_to_movie_id_to_rating)): 
#     if(len(movie_id_to_ratings_total[train_users.user_to_target_movie_id[i]])==1):
#         train_users.feature_2.append(overall_average_train)
#     else:
#         train_users.feature_2.append(float(((movie_id_to_average_rating_train[train_users.user_to_target_movie_id[i]]
#                         *len(movie_id_to_ratings_total[train_users.user_to_target_movie_id[i]]))
#                         -train_users.user_to_movie_id_to_rating[i][train_users.user_to_target_movie_id[i]])
#                         /(len(movie_id_to_ratings_total[train_users.user_to_target_movie_id[i]])-1)))


# for i in range(len(test_users.user_to_movie_id_to_rating)):
#     if(test_users.user_to_target_movie_id[i] not in movie_id_to_ratings_total.keys()):
#         test_users.feature_2.append(overall_average_train)
#     else:
#         test_users.feature_2.append(movie_id_to_average_rating_train[test_users.user_to_target_movie_id[i]])



# def populate_6(user_to_ratings_full_transform, user_to_ratings_full, user_to_target_index_full, 
#                user_to_movie_id_to_rating, user_to_target_movie_id):
#     for i in range(len(user_to_movie_id_to_rating)):
#         ratings = []
#         index = 0
#         for movie_id in movies_in_order:
#             if movie_id == user_to_target_movie_id[i]:
#                 user_to_target_index_full.append(index)
#             if movie_id in user_to_movie_id_to_rating[i].keys():
#                 ratings.append(user_to_movie_id_to_rating[i][movie_id])
#             elif movie_id in movie_id_to_average_rating_train.keys():
#                 ratings.append(movie_id_to_average_rating_train[movie_id])
#             else:   
#                 ratings.append(overall_average_train)
#             index +=1
#         user_to_ratings_full.append(ratings)
#         user_to_ratings_full_transform.append([x - user_to_average_rating[i] for x in ratings])


# populate_6(train_users.user_to_ratings_full_transform, train_users.user_to_ratings_full, train_users.user_to_target_index_full, train_users.user_to_movie_id_to_rating, train_users.user_to_target_movie_id)
# populate_6(test_users.user_to_ratings_full_transform, test_users.user_to_ratings_full, test_users.user_to_target_index_full, test_users.user_to_movie_id_to_rating, test_users.user_to_target_movie_id)


# del train_users.user_to_movie_id_to_rating
# del test_users.user_to_movie_id_to_rating
# del train_users.user_to_target_movie_id
# del test_users.user_to_target_movie_id

#why is feature 3 outperformed by feature 2 ???

# def populate_7(user_to_ratings_full_transform, user_to_ratings_full, user_to_target_index_full, feature_3):
#     for i in range(len(user_to_ratings_full)):
#         list_of_list_of_ratings = []
#         sample_ratings = []
#         for j in range(len(train_users.user_to_ratings_full)):
#             if i != j:
#                 sample_ratings.append(train_users.user_to_ratings_full[j][user_to_target_index_full[i]])
#                 ratings = [train_users.user_to_ratings_full_transform[j][x] 
#                           for x 
#                           in range(len(train_users.user_to_ratings_full_transform[j])) 
#                           if x != user_to_target_index_full[i]]
#                 list_of_list_of_ratings.append(ratings)

#         user_ratings = [user_to_ratings_full_transform[i][x] 
#                     for x 
#                     in range(len(user_to_ratings_full_transform[i])) 
#                     if x != user_to_target_index_full[i]]


#         sim  = cosine_similarity(X = list_of_list_of_ratings, Y = [user_ratings])
#         sim = np.reshape(sim,  (len(sim)))

#         combined = zip(sim, sample_ratings)
#         combined = sorted(combined, key=lambda x: x[0], reverse = True)

#         avg = 0
#         nof = 10.0
#         for k in range(int(nof)):
#             avg+= combined[k][1]

#         feature_3.append(float(avg/nof))
    

# populate_7(train_users.user_to_ratings_full_transform, train_users.user_to_ratings_full, train_users.user_to_target_index_full, train_users.feature_3)
# populate_7(test_users.user_to_ratings_full_transform, test_users.user_to_ratings_full, test_users.user_to_target_index_full, test_users.feature_3)

# del train_users.user_to_ratings_full_transform
# del test_users.user_to_ratings_full_transform
# del train_users.user_to_ratings_full
# del test_users.user_to_ratings_full
# del train_users.user_to_target_index_full
# del test_users.user_to_target_index_full

# def populate_2(user_to_movie_id_to_corpus, user_to_words_in_order):
#     for i in range(len(user_to_movie_id_to_corpus)):
#         user_to_words_in_order.append(OrderedSet())
#         for movie_id in user_to_movie_id_to_corpus[i].keys():
#             for word in user_to_movie_id_to_corpus[i][movie_id]:
#                 user_to_words_in_order[i].add(word)

# populate_2(train_users.user_to_movie_id_to_corpus,  train_users.user_to_words_in_order)
# populate_2(test_users.user_to_movie_id_to_corpus,  test_users.user_to_words_in_order)



# def populate_3(user_to_movie_id_to_corpus, user_to_target_movie_id, user_to_movie_id_to_rating,
#     user_to_target_rating, user_to_ratings):
#     for i in range(len(user_to_movie_id_to_corpus)):
#         temp = []
#         cnt = 0
#         for movie_id in user_to_movie_id_to_corpus[i].keys():
#             if movie_id != user_to_target_movie_id[i]:
#                 temp.append(user_to_movie_id_to_rating[i][movie_id])
#             else:
#                 user_to_target_rating.append(user_to_movie_id_to_rating[i][movie_id])
#                 temp.append(-1)
#             cnt+=1
#         user_to_ratings.append(temp)


# populate_3(train_users.user_to_movie_id_to_corpus, train_users.user_to_target_movie_id, train_users.user_to_movie_id_to_rating,
#             train_users.user_to_target_rating, train_users.user_to_ratings)
# populate_3(test_users.user_to_movie_id_to_corpus, test_users.user_to_target_movie_id, test_users.user_to_movie_id_to_rating,
#             test_users.user_to_target_rating, test_users.user_to_ratings)



# def populate_4(user_to_word_counts_transformed, user_to_target_word_counts_transformed,
#                 user_to_movie_id_to_corpus, user_to_word_counts,
#                 user_to_target_movie_id, user_to_words_in_order, user_to_target_word_counts):
#     for i in range(len(user_to_movie_id_to_corpus)):
#         user_to_word_counts.append([])
#         user_to_word_counts_transformed.append([])
#         for movie_id in user_to_movie_id_to_corpus[i].keys():
#             if movie_id != user_to_target_movie_id[i]:
#                 temp_dict = Counter(user_to_movie_id_to_corpus[i][movie_id])
#                 temp_list = []
#                 avg = 0
#                 for word in user_to_words_in_order[i]:
#                     if word in temp_dict.keys():
#                         temp_list.append(temp_dict[word])
#                         avg+=temp_dict[word]
#                     else:
#                         temp_list.append(0)
#                 avg = float(avg/len(user_to_words_in_order[i]))
#                 user_to_word_counts[i].append(temp_list)
#                 user_to_word_counts_transformed[i].append([x - avg for x in temp_list])
#             else:

#                 temp_dict = Counter(user_to_movie_id_to_corpus[i][movie_id])
#                 temp_list = []
#                 avg = 0
#                 for word in user_to_words_in_order[i]:
#                     if word in temp_dict.keys():
#                         temp_list.append(temp_dict[word])
#                         avg+=temp_dict[word]
#                     else:
#                         temp_list.append(0)
#                 avg = float(avg/len(user_to_words_in_order[i]))
#                 user_to_target_word_counts.append(temp_list)
#                 user_to_target_word_counts_transformed.append([x - avg for x in temp_list])


# populate_4(train_users.user_to_word_counts_transformed, train_users.user_to_target_word_counts_transformed,
#            train_users.user_to_movie_id_to_corpus, train_users.user_to_word_counts, train_users.user_to_target_movie_id,
#        train_users.user_to_words_in_order, train_users.user_to_target_word_counts)

# populate_4(test_users.user_to_word_counts_transformed, test_users.user_to_target_word_counts_transformed,
#            test_users.user_to_movie_id_to_corpus, test_users.user_to_word_counts, 
#        test_users.user_to_target_movie_id, test_users.user_to_words_in_order, test_users.user_to_target_word_counts)

# del train_users.user_to_words_in_order
# del train_users.user_to_movie_id_to_corpus
# del test_users.user_to_words_in_order
# del test_users.user_to_movie_id_to_corpus